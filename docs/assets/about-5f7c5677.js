import{v as e}from"./index-81412148.js";const{div:t,blockquote:o,br:a,code:s,h1:i,h2:n,h3:r,li:l,p:c,pre:h,ul:d}=e.tags,m=()=>t({class:"container mt-2"},t({class:"box content"},i({class:"title is-2"},"Budget Dashboard"),c("After being introduce to VanJS, I thought it would be interesting to build an application to review some bank transactions. And hopefully, come up with a form of a budget. Ha!",a(),"Some features would be to:"),d(l("Display a list of bank transactions"),l("Import transaction via a CSV file"),l("Edit memo and tags for a transaction"),l("Search and filtering transactions"),l("Removing a transaction.")),c("Some nice-to-have:"),d(l("Tag rule wizard"),l("Charts w/ page data slicers"),l("Reports")),c("Having a strong background in VueJS and TypeScript, you might see some similar approach find in VueJS, like Views, Components, Router, and Stores. Also, I am a strong advocate for TypeScript. So use it, love it :-)"),n({class:"title is-3"},"CSS and Theme"),c("For this project, we are using SCSS along with the Bulma CSS library. Bulma is loaded via CDN provide by CloudFlare."),n({class:"title is-3"},"Route and Views"),c("IMHO, Views components are the same as routes. When you hit the 'About' page from the URL, you are displayed with the 'About' component. Under the ",s("src/routes")," directory, you will find both routing logic and view components."),r({class:"title is-4"},"Asynchronous Component"),c("Component at the router/view level might be asynchronous. The best way to handle was to test for a ",s("typeof Promise"),' and use the "Await" library provided in the VanJS-UI kit.'),o(c('NOTE: VanJS-UI kit is NOT used in this project. I only copied the "Await" method. See ',s("src/lib/await.ts"),".")),c("I my recent release, I was able to import the route component by doing this."),h(s({class:"language-ts"},'{\n  path: "/about",\n  component: import("./about"),\n  meta: {},\n},\n')),c("Importing a route convert the return result from ",s("typeof Promise")," to a ",s("typeof Module"),". Doing this approach, in-sure the component is not rendered or executed until it's actual needed."),n({class:"title is-3"},"Props, Slot, and Emitters"),c('Oftentimes, components might be a shell that is usable. One example of this is a Modal. Modal is a window that appears over all other windows and can display various types of content. "Modal-Frame" in this project, uses props, slot, and emitters. See ',s("src/components/modal-frame.ts")),d(l("Props use to pass in data from the parent component to the child component (Modal-Frame)."),l("Slot is the HTML content to display in the body of the Modal-Frame."),l("Emitter is the action triggered by the child component (Modal-Frame) back to the parent component.")),n({class:"title is-3"},"Central Store"),c("VanJS is able to maintain a reactive state. This makes is easy to create a central store that allows all components to read and write data from a single-source-of-truth. To keep things clean, the store is broken into module and are namespace. See ",s("src/stores/index.ts"),"."),n({class:"title is-3"},"API and Data Store"),c('To get things moving, HTTP client is a wrapper around Fetch API with the attempt to closely match Axios client (as far as general use). The "swagger-client" is the controller for sending/receiving requests. So the "swagger-client" might act a API middleware before calling the LocalDB.'),c("LocalDB is a library for CRUD operations to the browser's local-storage."),c("Once the actual API is ready, we should be to easily switch from LocalDB to API endpoints."),i({class:"title is-3"},"Contribute"),c("See a better way to achieving something or features that would be useful, submit a pull-requests!"),i({class:"title is-3"},"License"),c("MIT")));export{m as About};
